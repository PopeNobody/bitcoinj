diff --git a/core/src/test/java/org/bitcoinj/script/ScriptTest.java b/core/src/test/java/org/bitcoinj/script/ScriptTest.java
index 056a636c6..56d196287 100644
--- a/core/src/test/java/org/bitcoinj/script/ScriptTest.java
+++ b/core/src/test/java/org/bitcoinj/script/ScriptTest.java
@@ -1,6 +1,7 @@
 /*
  * Copyright 2011 Google Inc.
  * Copyright 2014 Andreas Schildbach
+ * Copyright 2017 Thomas KÃ¶nig
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -42,6 +43,8 @@ import java.nio.charset.Charset;
 import java.util.*;
 
 import static org.bitcoinj.core.Utils.HEX;
+import static org.bitcoinj.core.Utils.toByteArray;
+import static org.bitcoinj.script.Script.MAX_SCRIPT_ELEMENT_SIZE;
 import static org.bitcoinj.script.ScriptOpCodes.OP_0;
 import static org.bitcoinj.script.ScriptOpCodes.OP_INVALIDOPCODE;
 import static org.hamcrest.core.IsEqual.equalTo;
@@ -122,7 +125,7 @@ public class ScriptTest {
         Script s = new Script(bytes);
         assertTrue(s.isSentToRawPubKey());
     }
-    
+
     @Test
     public void testCreateMultiSigInputScript() {
         // Setup transaction and signatures
@@ -233,9 +236,10 @@ public class ScriptTest {
         assertEquals("OP_0 push length", 0, stack.get(0).length);
     }
 
+
     private Script parseScriptString(String string) throws IOException {
         String[] words = string.split("[ \\t\\n]");
-        
+
         UnsafeByteArrayOutputStream out = new UnsafeByteArrayOutputStream();
 
         for(String w : words) {
@@ -263,9 +267,9 @@ public class ScriptTest {
                 out.write(ScriptOpCodes.getOpCode(w.substring(3)));
             } else {
                 throw new RuntimeException("Invalid Data");
-            }                        
+            }
         }
-        
+
         return new Script(out.toByteArray());
     }
 
@@ -282,7 +286,7 @@ public class ScriptTest {
         }
         return flags;
     }
-    
+
     @Test
     public void dataDrivenValidScripts() throws Exception {
         JsonNode json = new ObjectMapper().readTree(new InputStreamReader(getClass().getResourceAsStream(
@@ -300,7 +304,7 @@ public class ScriptTest {
             }
         }
     }
-    
+
     @Test
     public void dataDrivenInvalidScripts() throws Exception {
         JsonNode json = new ObjectMapper().readTree(new InputStreamReader(getClass().getResourceAsStream(
@@ -319,7 +323,7 @@ public class ScriptTest {
             }
         }
     }
-    
+
     private Map<TransactionOutPoint, Script> parseScriptPubKeys(JsonNode inputs) throws IOException {
         Map<TransactionOutPoint, Script> scriptPubKeys = new HashMap<TransactionOutPoint, Script>();
         for (JsonNode input : inputs) {
@@ -491,4 +495,287 @@ public class ScriptTest {
             ((byte) 133) // Pushed data
         }, builder.build().getProgram());
     }
+
+    @Test
+    public void numberBuilder16() {
+        ScriptBuilder builder = new ScriptBuilder();
+        // Numbers greater than 16 must be encoded with PUSHDATA
+        builder.number(15).number(16).number(17);
+        builder.number(0, 17).number(1, 16).number(2, 15);
+        Script script = builder.build();
+        assertEquals("PUSHDATA(1)[11] 16 15 15 16 PUSHDATA(1)[11]", script.toString());
+    }
+
+    /** Bitwise ops **/
+
+    static final int MAX_BITWISE_RANDOM_TESTS = 2000;
+
+    @Test
+    public void testBitwiseRandomData() throws IOException {
+        byte[] a = new byte[MAX_BITWISE_RANDOM_TESTS];
+        byte[] b = new byte[MAX_BITWISE_RANDOM_TESTS];
+        new Random(0).nextBytes(a); //using the same seed always generates the same byte array
+        new Random(1).nextBytes(b);
+
+        for (int x = 0 ; x < MAX_BITWISE_RANDOM_TESTS ; x++) {
+            byte aandb = (byte)(a[x] & b[x]);
+            byte aorb  = (byte)(a[x] | b[x]);
+            byte axorb = (byte)(a[x] ^ b[x]);
+
+            Assert.assertEquals(bitwiseScript(a[x], b[x], "AND"), aandb);
+            Assert.assertEquals(bitwiseScript(b[x], a[x], "AND"), aandb);
+            Assert.assertEquals(bitwiseScript(a[x], b[x], "OR"), aorb);
+            Assert.assertEquals(bitwiseScript(b[x], a[x], "OR"), aorb);
+            Assert.assertEquals(bitwiseScript(a[x], b[x], "XOR"), axorb);
+            Assert.assertEquals(bitwiseScript(b[x], a[x], "XOR"), axorb);
+        }
+    }
+
+    @Test
+    public void testBitwiseOpcodes() {
+        for (int x = 0; x < ScriptTestBitwiseData.a.length ; x++) {
+            byte a = ScriptTestBitwiseData.a[x];
+            byte b = ScriptTestBitwiseData.b[x];
+            byte expected_xor = (byte)(a^b);
+
+            Assert.assertEquals(bitwiseScript(a, b, "AND"), ScriptTestBitwiseData.aandb[x]);
+            Assert.assertEquals(bitwiseScript(b, a, "AND"), ScriptTestBitwiseData.aandb[x]);
+            Assert.assertEquals(bitwiseScript(a, b, "OR"),  ScriptTestBitwiseData.aorb[x]);
+            Assert.assertEquals(bitwiseScript(b, a, "OR"),  ScriptTestBitwiseData.aorb[x]);
+            Assert.assertEquals(bitwiseScript(a, b, "XOR"), expected_xor);
+            Assert.assertEquals(bitwiseScript(b, a, "XOR"), expected_xor);
+        }
+    }
+
+    private byte bitwiseScript(byte a, byte b, String opcode) {
+        byte[] result = bitwiseScript(new byte[]{a}, new byte[]{b}, opcode);
+        return result[0];
+    }
+
+    private byte[] bitwiseScript(byte[] a, byte[] b, String opcode) {
+        ScriptBuilder builder = new ScriptBuilder();
+        if (a != null) {
+            builder.data(a);
+        }
+        if (b != null) {
+            builder.data(b);
+        }
+        builder.op(ScriptOpCodes.getOpCode(opcode));
+        return executeMonolithScript(builder.build());
+    }
+
+    private void executeFailedMonolithScript(Script script, String message) {
+        try {
+            executeMonolithScript(script);
+            fail("Script should fails with '"+message+"'");
+        } catch (ScriptException e) {
+            Assert.assertEquals(message, e.getMessage());
+        }
+    }
+    private byte[] executeMonolithScript(Script script) {
+        LinkedList<byte[]> stack = new LinkedList<byte[]>();
+        EnumSet<VerifyFlag> verifyFlags = EnumSet.noneOf(VerifyFlag.class);
+        verifyFlags.add(VerifyFlag.MONOLITH_OPCODES);
+        Script.executeScript(new Transaction(PARAMS), 0, script, stack, Coin.ZERO, verifyFlags);
+        return stack.peekLast();
+    }
+
+
+    /** Number encoding **/
+
+    public void checkMinimallyEncoded(byte[] data, byte[] expected) {
+        boolean alreadyEncoded = Utils.checkMinimallyEncodedLE(data, data.length);
+        byte[] encoded = Utils.minimallyEncodeLE(data);
+        boolean hasEncoded = data.length != encoded.length;
+        assertEquals(hasEncoded, !alreadyEncoded);
+        assertArrayEquals(encoded, expected);
+    }
+
+    @Test
+    public void minimizeEncodingTest() {
+        checkMinimallyEncoded(new byte[0], new byte[0]);
+
+        try {
+
+            UnsafeByteArrayOutputStream zero = new UnsafeByteArrayOutputStream();
+            UnsafeByteArrayOutputStream negZero = new UnsafeByteArrayOutputStream();
+            for (int i = 0; i < Script.MAX_SCRIPT_ELEMENT_SIZE; i++) {
+
+                zero.write(0x00);
+                checkMinimallyEncoded(zero.toByteArray(), new byte[0]);
+
+                negZero.write(0x80);
+                checkMinimallyEncoded(negZero.toByteArray(), new byte[0]);
+
+                //reset negZero for next round
+                int len = negZero.size();
+                negZero.reset();
+                negZero.write(new byte[len]);
+
+            }
+
+            // Keep one leading zero when sign bit is used.
+            byte[] n = new byte[]{(byte) 0x80, (byte) 0x00};
+            byte[] negn = new byte[]{(byte) 0x80, (byte) 0x80};
+            UnsafeByteArrayOutputStream nPadded = new UnsafeByteArrayOutputStream();
+            nPadded.write(n);
+            UnsafeByteArrayOutputStream negnPadded = new UnsafeByteArrayOutputStream();
+            negnPadded.write(negn);
+
+            for (int i = 0; i < Script.MAX_SCRIPT_ELEMENT_SIZE; i++) {
+                checkMinimallyEncoded(nPadded.toByteArray(), n);
+                nPadded.write(0x00);
+
+                byte[] negnPaddedBytes = negnPadded.toByteArray();
+                checkMinimallyEncoded(negnPaddedBytes, negn);
+
+                //reset to move the 0x80 one to the right
+                negnPadded.reset();
+                negnPadded.write(negnPaddedBytes, 0, negnPaddedBytes.length - 1);
+                negnPadded.write(0x00);
+                negnPadded.write(0x80);
+            }
+
+            // Merge leading byte when sign bit isn't used
+            byte[] k = new byte[]{(byte) 0x7f};
+            byte[] negk = new byte[]{(byte) 0xff};
+            UnsafeByteArrayOutputStream kPadded = new UnsafeByteArrayOutputStream();
+            kPadded.write(k);
+            UnsafeByteArrayOutputStream negkPadded = new UnsafeByteArrayOutputStream();
+            negkPadded.write(negk);
+
+            for (int i = 0; i < Script.MAX_SCRIPT_ELEMENT_SIZE; i++) {
+                checkMinimallyEncoded(kPadded.toByteArray(), k);
+                kPadded.write(0x00);
+
+                byte[] negkPaddedBytes = negkPadded.toByteArray();
+                checkMinimallyEncoded(negkPaddedBytes, negk);
+
+                int last = negkPaddedBytes[negkPaddedBytes.length - 1] & 0x7f;
+                negkPadded.reset();
+                negkPadded.write(negkPaddedBytes, 0, negkPaddedBytes.length - 1);
+                negkPadded.write(last);
+                negkPadded.write(0x80);
+            }
+
+        } catch (IOException e) {
+            //catching UnsafeByteArrayOutputStream.write() should never happen
+            throw new RuntimeException(e);
+        }
+    }
+
+
+    /* CAT SPLIT ops */
+
+    @Test
+    public void testOpCat() {
+        final byte[] EMPTY = {};
+        final byte[] A = {'a'};
+        final byte[] A_B = {'a', 'b'};
+        final byte[] ZEROS_1 = {0x00};
+        final byte[] ZEROS_2 = {0x00, 0x00};
+        final byte[] ZEROS_4 = {0x00, 0x00, 0x00, 0x00};
+
+        Assert.assertArrayEquals(bitwiseScript(EMPTY, EMPTY, "CAT"), EMPTY);
+        Assert.assertArrayEquals(bitwiseScript(ZEROS_1, ZEROS_1, "CAT"), ZEROS_2);
+        Assert.assertArrayEquals(bitwiseScript(ZEROS_2, ZEROS_2, "CAT"), ZEROS_4);
+
+        Assert.assertArrayEquals(bitwiseScript(A, EMPTY, "CAT"), A);
+        Assert.assertArrayEquals(bitwiseScript(A_B, EMPTY, "CAT"), A_B);
+        Assert.assertArrayEquals(bitwiseScript(ZEROS_1, EMPTY, "CAT"), ZEROS_1);
+        Assert.assertArrayEquals(bitwiseScript(ZEROS_2, EMPTY, "CAT"), ZEROS_2);
+        Assert.assertArrayEquals(bitwiseScript(ZEROS_4, EMPTY, "CAT"), ZEROS_4);
+
+        Assert.assertArrayEquals(bitwiseScript(EMPTY, A, "CAT"), A);
+        Assert.assertArrayEquals(bitwiseScript(EMPTY, A_B, "CAT"), A_B);
+        Assert.assertArrayEquals(bitwiseScript(EMPTY, ZEROS_1, "CAT"), ZEROS_1);
+        Assert.assertArrayEquals(bitwiseScript(EMPTY, ZEROS_2, "CAT"), ZEROS_2);
+        Assert.assertArrayEquals(bitwiseScript(EMPTY, ZEROS_4, "CAT"), ZEROS_4);
+
+        Assert.assertArrayEquals(bitwiseScript(A_B, new byte[]{'c', 'd'}, "CAT"), new byte[]{'a', 'b', 'c', 'd'});
+
+
+        for (int x = 0; x < MAX_SCRIPT_ELEMENT_SIZE ; x++) {
+            int firstSize = x;
+            int secondSize = (int)MAX_SCRIPT_ELEMENT_SIZE - x;
+            byte[] first = new byte[firstSize];
+            byte[] second = new byte[secondSize];
+            byte[] cat = new byte[(int)MAX_SCRIPT_ELEMENT_SIZE];
+            System.arraycopy(ScriptTestBitwiseData.a, 0, first, 0, firstSize);
+            System.arraycopy(ScriptTestBitwiseData.b, 0, second, 0, secondSize);
+
+            System.arraycopy(ScriptTestBitwiseData.a, 0, cat, 0, firstSize);
+            System.arraycopy(ScriptTestBitwiseData.b, 0, cat, firstSize, secondSize);
+
+            Assert.assertArrayEquals(bitwiseScript(first, second, "CAT"), cat);
+
+            if (firstSize != 0 && secondSize != 0) {
+                // Try overflow
+                byte[] secondOverflow = new byte[secondSize + 1];
+                System.arraycopy(ScriptTestBitwiseData.a, 0, secondOverflow, 0, secondSize + 1);
+
+                try {
+                    Assert.assertArrayEquals(bitwiseScript(first, secondOverflow, "CAT"), cat);
+                    fail("CAT should fail when result is more than " + MAX_SCRIPT_ELEMENT_SIZE);
+                } catch (ScriptException e) {
+                    Assert.assertEquals("Push value size limit exceeded.", e.getMessage());
+                }
+            }
+
+        }
+    }
+    @Test
+    public void testOpSplit() {
+        final byte[] EMPTY = {};
+        final byte[] A = {'a'};
+        final byte[] B = {'b'};
+        final byte[] A_B = {'a', 'b'};
+
+        Assert.assertArrayEquals(EMPTY, executeMonolithScript(new ScriptBuilder().data(EMPTY).number(0).op(ScriptOpCodes.OP_SPLIT).build()));
+
+        Assert.assertArrayEquals(A, executeMonolithScript(new ScriptBuilder().data(A).number(0).op(ScriptOpCodes.OP_SPLIT).build()));
+        Assert.assertArrayEquals(EMPTY, executeMonolithScript(new ScriptBuilder().data(A).number(A.length).op(ScriptOpCodes.OP_SPLIT).build()));
+
+        Assert.assertArrayEquals(A_B, executeMonolithScript(new ScriptBuilder().data(A_B).number(0).op(ScriptOpCodes.OP_SPLIT).build()));
+        Assert.assertArrayEquals(B, executeMonolithScript(new ScriptBuilder().data(A_B).number(1).op(ScriptOpCodes.OP_SPLIT).build()));
+        Assert.assertArrayEquals(EMPTY, executeMonolithScript(new ScriptBuilder().data(A_B).number(2).op(ScriptOpCodes.OP_SPLIT).build()));
+
+        executeFailedMonolithScript(new ScriptBuilder().op(ScriptOpCodes.OP_SPLIT).build(), "Invalid stack operation.");
+        executeFailedMonolithScript(new ScriptBuilder().data(EMPTY).number(1).op(ScriptOpCodes.OP_SPLIT).build(), "Invalid OP_SPLIT range.");
+    }
+
+    /** BIN2NUM **/
+
+    @Test
+    public void testBin2Num() {
+        // known values
+        checkBin2NumOp(toByteArray(0xab, 0xcd, 0xef, 0x00), toByteArray(0xab, 0xcd, 0xef, 0x00));
+        checkBin2NumOp(toByteArray(0xab, 0xcd, 0x7f), toByteArray(0xab, 0xcd, 0x7f, 0x00));
+
+        // reductions
+        checkBin2NumOp(toByteArray(0xab, 0xcd, 0xef, 0xc2), toByteArray(0xab, 0xcd, 0xef, 0x42, 0x80));
+        checkBin2NumOp(toByteArray(0xab, 0xcd, 0x7f, 0x42), toByteArray(0xab, 0xcd, 0x7f, 0x42, 0x00));
+
+        // Empty stack
+        executeFailedMonolithScript(new ScriptBuilder().op(ScriptOpCodes.OP_BIN2NUM).build(), "Invalid stack operation.");
+        executeFailedMonolithScript(new ScriptBuilder().op(ScriptOpCodes.OP_NUM2BIN).build(), "Invalid stack operation.");
+
+        // Values that do not fit in 4 bytes are considered out of range for BIN2NUM
+        executeFailedMonolithScript(new ScriptBuilder().data(toByteArray(0xab, 0xcd, 0xef, 0xc2, 0x80)).op(ScriptOpCodes.OP_BIN2NUM).build(), "Given operand is not a number within the valid range [-2^31...2^31]");
+        executeFailedMonolithScript(new ScriptBuilder().data(toByteArray(0x00, 0x00, 0x00, 0x80, 0x80)).op(ScriptOpCodes.OP_BIN2NUM).build(), "Given operand is not a number within the valid range [-2^31...2^31]");
+
+        // NUM2BIN require 2 elements on the stack.
+        executeFailedMonolithScript(new ScriptBuilder().data(toByteArray( 0x00)).op(ScriptOpCodes.OP_NUM2BIN).build(), "Invalid stack operation.");
+
+        executeFailedMonolithScript(new ScriptBuilder().data(new byte[0]).data(toByteArray(0x09, 0x02)).op(ScriptOpCodes.OP_NUM2BIN).build(), "Push value size limit exceeded.");
+
+        // Check that the requested encoding is possible.
+        executeFailedMonolithScript(new ScriptBuilder().data(toByteArray(0xab, 0xcd, 0xef, 0x80)).data(toByteArray(0x03)).op(ScriptOpCodes.OP_NUM2BIN).build(), "The requested encoding is impossible to satisfy.");
+    }
+
+    private void checkBin2NumOp(byte[] n, byte[] expected) {
+        Assert.assertArrayEquals(n, executeMonolithScript(new ScriptBuilder().data(expected).op(ScriptOpCodes.OP_BIN2NUM).build()));
+        Assert.assertArrayEquals(expected, executeMonolithScript(new ScriptBuilder().data(n).data(new byte[]{(byte)expected.length}).op(ScriptOpCodes.OP_NUM2BIN).build()));
+    }
+
 }
