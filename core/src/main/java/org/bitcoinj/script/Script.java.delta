diff --git a/core/src/main/java/org/bitcoinj/script/Script.java b/core/src/main/java/org/bitcoinj/script/Script.java
index 9ddb45ca7..2757d61e0 100644
--- a/core/src/main/java/org/bitcoinj/script/Script.java
+++ b/core/src/main/java/org/bitcoinj/script/Script.java
@@ -2,6 +2,7 @@
  * Copyright 2011 Google Inc.
  * Copyright 2012 Matt Corallo.
  * Copyright 2014 Andreas Schildbach
+ * Copyright 2018 the bitcoinj-cash developers
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,6 +15,9 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file has been modified by the bitcoinj-cash developers for the bitcoinj-cash project.
+ * The original file was from the bitcoinj project (https://github.com/bitcoinj/bitcoinj).
  */
 
 package org.bitcoinj.script;
@@ -62,7 +66,7 @@ public class Script {
         P2SH
     }
 
-    /** Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Set)}.
+    /** Flags to pass to {@link Script#correctlySpends(Transaction, long, Script, Coin, Set)}.
      * Note currently only P2SH, DERSIG and NULLDUMMY are actually supported.
      */
     public enum VerifyFlag {
@@ -72,15 +76,18 @@ public class Script {
         LOW_S, // Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure
         NULLDUMMY, // Verify dummy stack item consumed by CHECKMULTISIG is of zero-length.
         SIGPUSHONLY, // Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).
-        MINIMALDATA, // Require minimal encodings for all push operations
+        MINIMALDATA, // Require minimal encodings for all push operations and number encodings
         DISCOURAGE_UPGRADABLE_NOPS, // Discourage use of NOPs reserved for upgrades (NOP1-10)
         CLEANSTACK, // Require that only a single stack element remains after evaluation.
-        CHECKLOCKTIMEVERIFY // Enable CHECKLOCKTIMEVERIFY operation
+        CHECKLOCKTIMEVERIFY, // Enable CHECKLOCKTIMEVERIFY operation
+        ENABLESIGHASHFORKID,
+        MONOLITH_OPCODES // May 15, 2018 Hard fork
     }
     public static final EnumSet<VerifyFlag> ALL_VERIFY_FLAGS = EnumSet.allOf(VerifyFlag.class);
 
     private static final Logger log = LoggerFactory.getLogger(Script.class);
     public static final long MAX_SCRIPT_ELEMENT_SIZE = 520;  // bytes
+    public static final int DEFAULT_MAX_NUM_ELEMENT_SIZE = 4;
     public static final int SIG_SIZE = 75;
     /** Max number of sigops allowed in a standard p2sh redeem script */
     public static final int MAX_P2SH_SIGOPS = 15;
@@ -304,7 +311,6 @@ public class Script {
 
     /**
      * Retrieves the sender public key from a LOCKTIMEVERIFY transaction
-     * @return
      * @throws ScriptException
      */
     public byte[] getCLTVPaymentChannelSenderPubKey() throws ScriptException {
@@ -316,7 +322,6 @@ public class Script {
 
     /**
      * Retrieves the recipient public key from a LOCKTIMEVERIFY transaction
-     * @return
      * @throws ScriptException
      */
     public byte[] getCLTVPaymentChannelRecipientPubKey() throws ScriptException {
@@ -330,7 +335,9 @@ public class Script {
         if (!isSentToCLTVPaymentChannel()) {
             throw new ScriptException("Script not a standard CHECKLOCKTIMEVERIFY transaction: " + this);
         }
-        return castToBigInteger(chunks.get(4).data, 5);
+        //FIXME We may actually need to enforce minimal encoding here.  But we don't have access
+        //to the verify flags
+        return castToBigInteger(chunks.get(4).data, 5, false);
     }
 
     /**
@@ -711,7 +718,7 @@ public class Script {
             }
             // First chunk must be an OP_N opcode too.
             if (decodeFromOpN(chunks.get(0).opcode) < 1) return false;
-        } catch (IllegalStateException e) {
+        } catch (IllegalArgumentException e) { // thrown by decodeFromOpN()
             return false;   // Not an OP_N opcode.
         }
         return true;
@@ -790,7 +797,7 @@ public class Script {
     
     ////////////////////// Script verification and helpers ////////////////////////////////
     
-    private static boolean castToBool(byte[] data) {
+    public static boolean castToBool(byte[] data) {
         for (int i = 0; i < data.length; i++)
         {
             // "Can be negative zero" - Bitcoin Core (see OpenSSL's BN_bn2mpi)
@@ -803,28 +810,34 @@ public class Script {
     /**
      * Cast a script chunk to a BigInteger.
      *
-     * @see #castToBigInteger(byte[], int) for values with different maximum
+     * @see #castToBigInteger(byte[], int, boolean) for values with different maximum
      * sizes.
      * @throws ScriptException if the chunk is longer than 4 bytes.
      */
-    private static BigInteger castToBigInteger(byte[] chunk) throws ScriptException {
-        if (chunk.length > 4)
+    private static BigInteger castToBigInteger(byte[] chunk, boolean enforceMinimal) throws ScriptException {
+        if (chunk.length > DEFAULT_MAX_NUM_ELEMENT_SIZE)
             throw new ScriptException("Script attempted to use an integer larger than 4 bytes");
-        return Utils.decodeMPI(Utils.reverseBytes(chunk), false);
+        if (enforceMinimal && !Utils.checkMinimallyEncodedLE(chunk, DEFAULT_MAX_NUM_ELEMENT_SIZE))
+            throw new ScriptException("Number is not minimally encoded");
+        //numbers on the stack or stored LE so convert as MPI requires BE.
+        byte[] bytesBE = Utils.reverseBytes(chunk);
+        return Utils.decodeMPI(bytesBE, false);
     }
 
     /**
      * Cast a script chunk to a BigInteger. Normally you would want
-     * {@link #castToBigInteger(byte[])} instead, this is only for cases where
+     * {@link #castToBigInteger(byte[], boolean)} instead, this is only for cases where
      * the normal maximum length does not apply (i.e. CHECKLOCKTIMEVERIFY).
      *
      * @param maxLength the maximum length in bytes.
      * @throws ScriptException if the chunk is longer than the specified maximum.
      */
-    private static BigInteger castToBigInteger(final byte[] chunk, final int maxLength) throws ScriptException {
+    private static BigInteger castToBigInteger(final byte[] chunk, final int maxLength, boolean enforceMinimal) throws ScriptException {
         if (chunk.length > maxLength)
             throw new ScriptException("Script attempted to use an integer larger than "
                 + maxLength + " bytes");
+        if (enforceMinimal && !Utils.checkMinimallyEncodedLE(chunk, 5))
+            throw new ScriptException("Number is not minimally encoded");
         return Utils.decodeMPI(Utils.reverseBytes(chunk), false);
     }
 
@@ -849,7 +862,50 @@ public class Script {
             ? EnumSet.of(VerifyFlag.NULLDUMMY)
             : EnumSet.noneOf(VerifyFlag.class);
 
-        executeScript(txContainingThis, index, script, stack, flags);
+        executeScript(txContainingThis, index, script, stack, Coin.ZERO, flags);
+    }
+
+    @Deprecated
+    public static void executeScript(@Nullable Transaction txContainingThis, long index,
+                                     Script script, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags) throws ScriptException {
+         executeScript(txContainingThis, index, script, stack, Coin.ZERO, verifyFlags);
+    }
+
+    private static boolean isOpcodeDisabled(int opcode, Set<VerifyFlag> verifyFlags) {
+
+
+        switch (opcode) {
+            case OP_INVERT:
+            case OP_LSHIFT:
+            case OP_RSHIFT:
+
+            case OP_2MUL:
+            case OP_2DIV:
+            case OP_MUL:
+                //disabled codes
+                return true;
+
+            case OP_CAT:
+            case OP_SPLIT:
+            case OP_AND:
+            case OP_OR:
+            case OP_XOR:
+            case OP_DIV:
+            case OP_MOD:
+            case OP_NUM2BIN:
+            case OP_BIN2NUM:
+                //enabled codes, still disabled if flag is not activated
+                return !verifyFlags.contains(VerifyFlag.MONOLITH_OPCODES);
+
+            default:
+                //not an opcode that was ever disabled
+                break;
+        }
+
+
+
+        return false;
+
     }
 
     /**
@@ -860,16 +916,66 @@ public class Script {
      * likely to change in future.
      */
     public static void executeScript(@Nullable Transaction txContainingThis, long index,
-                                     Script script, LinkedList<byte[]> stack, Set<VerifyFlag> verifyFlags) throws ScriptException {
+                                     Script script, LinkedList<byte[]> stack, Coin value, Set<VerifyFlag> verifyFlags) throws ScriptException {
+        executeScript(txContainingThis,index, script, stack, value, verifyFlags, null);
+    }
+
+    /**
+     * Executes a script in debug mode with the provided ScriptStateListener.  Exceptions (which are thrown when a script fails) are caught
+     * and passed to the listener before being rethrown.
+     */
+    public static void executeDebugScript(@Nullable Transaction txContainingThis, long index,
+                                     Script script, LinkedList<byte[]> stack, Coin value, Set<VerifyFlag> verifyFlags, ScriptStateListener scriptStateListener) throws ScriptException {
+        try {
+            executeScript(txContainingThis, index, script, stack, value, verifyFlags, scriptStateListener);
+        } catch (ScriptException e) {
+            scriptStateListener.onExceptionThrown(e);
+            try {
+                //pause to hopefully give the System.out time to beat System.err
+                Thread.sleep(200);
+            } catch (InterruptedException e1) {
+                e1.printStackTrace();
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Exposes the script interpreter. Normally you should not use this directly, instead use
+     * {@link org.bitcoinj.core.TransactionInput#verify(org.bitcoinj.core.TransactionOutput)} or
+     * {@link org.bitcoinj.script.Script#correctlySpends(org.bitcoinj.core.Transaction, long, Script)}. This method
+     * is useful if you need more precise control or access to the final state of the stack. This interface is very
+     * likely to change in future.
+     */
+    public static void executeScript(@Nullable Transaction txContainingThis, long index,
+                                     Script script, LinkedList<byte[]> stack, Coin value, Set<VerifyFlag> verifyFlags, ScriptStateListener scriptStateListener) throws ScriptException {
         int opCount = 0;
         int lastCodeSepLocation = 0;
-        
+
         LinkedList<byte[]> altstack = new LinkedList<byte[]>();
         LinkedList<Boolean> ifStack = new LinkedList<Boolean>();
-        
+        final boolean enforceMinimal = verifyFlags.contains(VerifyFlag.MINIMALDATA);
+
+        if (scriptStateListener != null) {
+            scriptStateListener.setInitialState(
+                    txContainingThis,
+                    index,
+                    script,
+                    Collections.unmodifiableList(stack),
+                    Collections.unmodifiableList(altstack),
+                    Collections.unmodifiableList(ifStack),
+                    value,
+                    verifyFlags
+            );
+        }
+
         for (ScriptChunk chunk : script.chunks) {
             boolean shouldExecute = !ifStack.contains(false);
 
+            if (scriptStateListener != null) {
+                scriptStateListener._onBeforeOpCodeExecuted(chunk, shouldExecute);
+            }
+
             if (chunk.opcode == OP_0) {
                 if (!shouldExecute)
                     continue;
@@ -893,13 +999,12 @@ public class Script {
                 
                 if (opcode == OP_VERIF || opcode == OP_VERNOTIF)
                     throw new ScriptException("Script included OP_VERIF or OP_VERNOTIF");
-                
-                if (opcode == OP_CAT || opcode == OP_SUBSTR || opcode == OP_LEFT || opcode == OP_RIGHT ||
-                    opcode == OP_INVERT || opcode == OP_AND || opcode == OP_OR || opcode == OP_XOR ||
-                    opcode == OP_2MUL || opcode == OP_2DIV || opcode == OP_MUL || opcode == OP_DIV ||
-                    opcode == OP_MOD || opcode == OP_LSHIFT || opcode == OP_RSHIFT)
+
+                // Some opcodes are disabled.
+                if (isOpcodeDisabled(opcode, verifyFlags)) {
                     throw new ScriptException("Script included a disabled Script Op.");
-                
+                }
+
                 switch (opcode) {
                 case OP_IF:
                     if (!shouldExecute) {
@@ -974,7 +1079,7 @@ public class Script {
                     break;
                 case OP_FROMALTSTACK:
                     if (altstack.size() < 1)
-                        throw new ScriptException("Attempted OP_TOALTSTACK on an empty altstack");
+                        throw new ScriptException("Attempted OP_FROMALTSTACK on an empty altstack");
                     stack.add(altstack.pollLast());
                     break;
                 case OP_2DROP:
@@ -1076,7 +1181,7 @@ public class Script {
                 case OP_ROLL:
                     if (stack.size() < 1)
                         throw new ScriptException("Attempted OP_PICK/OP_ROLL on an empty stack");
-                    long val = castToBigInteger(stack.pollLast()).longValue();
+                    long val = castToBigInteger(stack.pollLast(), enforceMinimal).longValue();
                     if (val < 0 || val >= stack.size())
                         throw new ScriptException("OP_PICK/OP_ROLL attempted to get data deeper than stack size");
                     Iterator<byte[]> itPICK = stack.descendingIterator();
@@ -1108,24 +1213,162 @@ public class Script {
                     if (opcode == OP_TUCK)
                         stack.add(OPSWAPtmpChunk2);
                     break;
+                //byte string operations
                 case OP_CAT:
-                case OP_SUBSTR:
-                case OP_LEFT:
-                case OP_RIGHT:
-                    throw new ScriptException("Attempted to use disabled Script Op.");
+                    if (stack.size() < 2)
+                        throw new ScriptException("Invalid stack operation.");
+                    byte[] catBytes2 = stack.pollLast();
+                    byte[] catBytes1 = stack.pollLast();
+
+                    int len = catBytes1.length + catBytes2.length;
+                    if (len > MAX_SCRIPT_ELEMENT_SIZE)
+                        throw new ScriptException("Push value size limit exceeded.");
+
+                    byte[] catOut = new byte[len];
+                    System.arraycopy(catBytes1, 0, catOut, 0, catBytes1.length);
+                    System.arraycopy(catBytes2, 0, catOut, catBytes1.length, catBytes2.length);
+                    stack.addLast(catOut);
+
+                    break;
+
+                case OP_SPLIT:
+                    if (stack.size() < 2)
+                        throw new ScriptException("Invalid stack operation.");
+
+                    BigInteger biSplitPos = castToBigInteger(stack.pollLast(), enforceMinimal);
+
+                    //sanity check in case we aren't enforcing minimal number encoding
+                    //we will check that the biSplitPos value can be safely held in an int
+                    //before we cast it as BigInteger will behave similar to casting if the value
+                    //is greater than the target type can hold.
+                    BigInteger biMaxInt = BigInteger.valueOf((long) Integer.MAX_VALUE);
+                    if (biSplitPos.compareTo(biMaxInt) >= 0)
+                        throw new ScriptException("Invalid OP_SPLIT range.");
+
+                    int splitPos = biSplitPos.intValue();
+                    byte[] splitBytes = stack.pollLast();
+
+                    if (splitPos > splitBytes.length || splitPos < 0)
+                        throw new ScriptException("Invalid OP_SPLIT range.");
+
+                    byte[] splitOut1 = new byte[splitPos];
+                    byte[] splitOut2 = new byte[splitBytes.length - splitPos];
+
+                    System.arraycopy(splitBytes, 0, splitOut1, 0, splitPos);
+                    System.arraycopy(splitBytes, splitPos, splitOut2, 0, splitOut2.length);
+
+                    stack.addLast(splitOut1);
+                    stack.addLast(splitOut2);
+                    break;
+
+                case OP_NUM2BIN:
+                    if (stack.size() < 2)
+                        throw new ScriptException("Invalid stack operation.");
+
+                    int numSize = castToBigInteger(stack.pollLast(), enforceMinimal).intValue();
+
+                    if (numSize > MAX_SCRIPT_ELEMENT_SIZE)
+                        throw new ScriptException("Push value size limit exceeded.");
+
+                    byte[] rawNumBytes = stack.pollLast();
+
+                    // Try to see if we can fit that number in the number of
+                    // byte requested.
+                    byte[] minimalNumBytes = Utils.minimallyEncodeLE(rawNumBytes);
+                    if (minimalNumBytes.length > numSize) {
+                        //we can't
+                        throw new ScriptException("The requested encoding is impossible to satisfy.");
+                    }
+
+                    if (minimalNumBytes.length == numSize) {
+                        //already the right size so just push it to stack
+                        stack.addLast(minimalNumBytes);
+                    } else if (numSize == 0) {
+                        stack.addLast(Utils.EMPTY_BYTE_ARRAY);
+                    } else {
+                        int signBit = 0x00;
+                        if (minimalNumBytes.length > 0) {
+                            signBit = minimalNumBytes[minimalNumBytes.length - 1] & 0x80;
+                            minimalNumBytes[minimalNumBytes.length - 1] &= 0x7f;
+                        }
+                        int minimalBytesToCopy = minimalNumBytes.length > numSize ? numSize : minimalNumBytes.length;
+                        byte[] expandedNumBytes = new byte[numSize]; //initialized to all zeroes
+                        System.arraycopy(minimalNumBytes, 0, expandedNumBytes, 0, minimalBytesToCopy);
+                        expandedNumBytes[expandedNumBytes.length - 1] = (byte) signBit;
+                        stack.addLast(expandedNumBytes);
+                    }
+                    break;
+
+                case OP_BIN2NUM:
+                    if (stack.size() < 1)
+                        throw new ScriptException("Invalid stack operation.");
+
+                    byte[] binBytes = stack.pollLast();
+                    byte[] numBytes = Utils.minimallyEncodeLE(binBytes);
+
+                    if (!Utils.checkMinimallyEncodedLE(numBytes, DEFAULT_MAX_NUM_ELEMENT_SIZE))
+                        throw new ScriptException("Given operand is not a number within the valid range [-2^31...2^31]");
+
+                    stack.addLast(numBytes);
+
+                    break;
                 case OP_SIZE:
                     if (stack.size() < 1)
                         throw new ScriptException("Attempted OP_SIZE on an empty stack");
                     stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.valueOf(stack.getLast().length), false)));
                     break;
                 case OP_INVERT:
+                    throw new ScriptException("Attempted to use disabled Script Op.");
                 case OP_AND:
                 case OP_OR:
                 case OP_XOR:
-                    throw new ScriptException("Attempted to use disabled Script Op.");
+                    // (x1 x2 - out)
+                    if (stack.size() < 2) {
+                        throw new ScriptException("Invalid stack operation.");
+                    }
+
+                    //valtype &vch1 = stacktop(-2);
+                    //valtype &vch2 = stacktop(-1);
+                    byte[] vch2 = stack.pollLast();
+                    byte[] vch1 = stack.pollLast();
+
+                    // Inputs must be the same size
+                    if (vch1.length != vch2.length) {
+                        throw new ScriptException("Invalid operand size.");
+                    }
+
+                    // To avoid allocating, we modify vch1 in place.
+                    switch (opcode) {
+                        case OP_AND:
+                            for (int i = 0; i < vch1.length; i++) {
+                                vch1[i] &= vch2[i];
+                            }
+                            break;
+                        case OP_OR:
+                            for (int i = 0; i < vch1.length; i++) {
+                                vch1[i] |= vch2[i];
+                            }
+                            break;
+                        case OP_XOR:
+                            for (int i = 0; i < vch1.length; i++) {
+                                vch1[i] ^= vch2[i];
+                            }
+                            break;
+                        default:
+                            break;
+                    }
+
+                    // And pop vch2.
+                    //popstack(stack);
+
+                    //put vch1 back on stack
+                    stack.addLast(vch1);
+
+                    break;
+
                 case OP_EQUAL:
                     if (stack.size() < 2)
-                        throw new ScriptException("Attempted OP_EQUALVERIFY on a stack with size < 2");
+                        throw new ScriptException("Attempted OP_EQUAL on a stack with size < 2");
                     stack.add(Arrays.equals(stack.pollLast(), stack.pollLast()) ? new byte[] {1} : new byte[] {});
                     break;
                 case OP_EQUALVERIFY:
@@ -1142,7 +1385,7 @@ public class Script {
                 case OP_0NOTEQUAL:
                     if (stack.size() < 1)
                         throw new ScriptException("Attempted a numeric op on an empty stack");
-                    BigInteger numericOPnum = castToBigInteger(stack.pollLast());
+                    BigInteger numericOPnum = castToBigInteger(stack.pollLast(), enforceMinimal);
                                         
                     switch (opcode) {
                     case OP_1ADD:
@@ -1181,6 +1424,8 @@ public class Script {
                     throw new ScriptException("Attempted to use disabled Script Op.");
                 case OP_ADD:
                 case OP_SUB:
+                case OP_DIV:
+                case OP_MOD:
                 case OP_BOOLAND:
                 case OP_BOOLOR:
                 case OP_NUMEQUAL:
@@ -1193,8 +1438,8 @@ public class Script {
                 case OP_MAX:
                     if (stack.size() < 2)
                         throw new ScriptException("Attempted a numeric op on a stack with size < 2");
-                    BigInteger numericOPnum2 = castToBigInteger(stack.pollLast());
-                    BigInteger numericOPnum1 = castToBigInteger(stack.pollLast());
+                    BigInteger numericOPnum2 = castToBigInteger(stack.pollLast(), enforceMinimal);
+                    BigInteger numericOPnum1 = castToBigInteger(stack.pollLast(), enforceMinimal);
 
                     BigInteger numericOPresult;
                     switch (opcode) {
@@ -1204,7 +1449,40 @@ public class Script {
                     case OP_SUB:
                         numericOPresult = numericOPnum1.subtract(numericOPnum2);
                         break;
-                    case OP_BOOLAND:
+
+                    case OP_DIV:
+                        if (numericOPnum2.intValue() == 0)
+                            throw new ScriptException("Division by zero error");
+                        numericOPresult = numericOPnum1.divide(numericOPnum2);
+                        break;
+
+                        case OP_MOD:
+                            if (numericOPnum2.intValue() == 0)
+                                throw new ScriptException("Modulo by zero error");
+
+                            /**
+                             * BigInteger doesn't behave the way we want for modulo operations.  Firstly it's
+                             * always garunteed to return a +ve result.  Secondly it will throw an exception
+                             * if the 2nd operand is negative.  So we'll convert the values to longs and use native
+                             * modulo.  When we expand the number limits to arbitrary length we will likely need
+                             * a new BigNum implementation to handle this correctly.
+                             */
+                            long lOp1 = numericOPnum1.longValue();
+                            if (!BigInteger.valueOf(lOp1).equals(numericOPnum1)) {
+                                //in case the value is larger than a long can handle we need to crash and burn.
+                                throw new RuntimeException("Cannot handle large negative operand for modulo operation");
+                            }
+                            long lOp2 = numericOPnum2.longValue();
+                            if (!BigInteger.valueOf(lOp2).equals(numericOPnum2)) {
+                                //in case the value is larger than a long can handle we need to crash and burn.
+                                throw new RuntimeException("Cannot handle large negative operand for modulo operation");
+                            }
+                            long lOpResult = lOp1 % lOp2;
+                            numericOPresult = BigInteger.valueOf(lOpResult);
+
+                            break;
+
+                        case OP_BOOLAND:
                         if (!numericOPnum1.equals(BigInteger.ZERO) && !numericOPnum2.equals(BigInteger.ZERO))
                             numericOPresult = BigInteger.ONE;
                         else
@@ -1271,16 +1549,14 @@ public class Script {
                     stack.add(Utils.reverseBytes(Utils.encodeMPI(numericOPresult, false)));
                     break;
                 case OP_MUL:
-                case OP_DIV:
-                case OP_MOD:
                 case OP_LSHIFT:
                 case OP_RSHIFT:
                     throw new ScriptException("Attempted to use disabled Script Op.");
                 case OP_NUMEQUALVERIFY:
                     if (stack.size() < 2)
                         throw new ScriptException("Attempted OP_NUMEQUALVERIFY on a stack with size < 2");
-                    BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(stack.pollLast());
-                    BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(stack.pollLast());
+                    BigInteger OPNUMEQUALVERIFYnum2 = castToBigInteger(stack.pollLast(), enforceMinimal);
+                    BigInteger OPNUMEQUALVERIFYnum1 = castToBigInteger(stack.pollLast(), enforceMinimal);
                     
                     if (!OPNUMEQUALVERIFYnum1.equals(OPNUMEQUALVERIFYnum2))
                         throw new ScriptException("OP_NUMEQUALVERIFY failed");
@@ -1288,9 +1564,9 @@ public class Script {
                 case OP_WITHIN:
                     if (stack.size() < 3)
                         throw new ScriptException("Attempted OP_WITHIN on a stack with size < 3");
-                    BigInteger OPWITHINnum3 = castToBigInteger(stack.pollLast());
-                    BigInteger OPWITHINnum2 = castToBigInteger(stack.pollLast());
-                    BigInteger OPWITHINnum1 = castToBigInteger(stack.pollLast());
+                    BigInteger OPWITHINnum3 = castToBigInteger(stack.pollLast(), enforceMinimal);
+                    BigInteger OPWITHINnum2 = castToBigInteger(stack.pollLast(), enforceMinimal);
+                    BigInteger OPWITHINnum1 = castToBigInteger(stack.pollLast(), enforceMinimal);
                     if (OPWITHINnum2.compareTo(OPWITHINnum1) <= 0 && OPWITHINnum1.compareTo(OPWITHINnum3) < 0)
                         stack.add(Utils.reverseBytes(Utils.encodeMPI(BigInteger.ONE, false)));
                     else
@@ -1337,13 +1613,13 @@ public class Script {
                 case OP_CHECKSIGVERIFY:
                     if (txContainingThis == null)
                         throw new IllegalStateException("Script attempted signature check but no tx was provided");
-                    executeCheckSig(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, verifyFlags);
+                    executeCheckSig(txContainingThis, (int) index, script, stack, lastCodeSepLocation, opcode, value, verifyFlags);
                     break;
                 case OP_CHECKMULTISIG:
                 case OP_CHECKMULTISIGVERIFY:
                     if (txContainingThis == null)
                         throw new IllegalStateException("Script attempted signature check but no tx was provided");
-                    opCount = executeMultiSig(txContainingThis, (int) index, script, stack, opCount, lastCodeSepLocation, opcode, verifyFlags);
+                    opCount = executeMultiSig(txContainingThis, (int) index, script, stack, opCount, lastCodeSepLocation, opcode, value, verifyFlags);
                     break;
                 case OP_CHECKLOCKTIMEVERIFY:
                     if (!verifyFlags.contains(VerifyFlag.CHECKLOCKTIMEVERIFY)) {
@@ -1376,10 +1652,19 @@ public class Script {
             
             if (stack.size() + altstack.size() > 1000 || stack.size() + altstack.size() < 0)
                 throw new ScriptException("Stack size exceeded range");
+
+            if (scriptStateListener != null) {
+                scriptStateListener.onAfterOpCodeExectuted();
+            }
         }
         
         if (!ifStack.isEmpty())
             throw new ScriptException("OP_IF/OP_NOTIF without OP_ENDIF");
+
+        if (scriptStateListener != null) {
+            scriptStateListener.onScriptComplete();
+        }
+
     }
 
     // This is more or less a direct translation of the code in Bitcoin Core
@@ -1391,7 +1676,7 @@ public class Script {
 
         // Thus as a special case we tell CScriptNum to accept up
         // to 5-byte bignums to avoid year 2038 issue.
-        final BigInteger nLockTime = castToBigInteger(stack.getLast(), 5);
+        final BigInteger nLockTime = castToBigInteger(stack.getLast(), 5, verifyFlags.contains(VerifyFlag.MINIMALDATA));
 
         if (nLockTime.compareTo(BigInteger.ZERO) < 0)
             throw new ScriptException("Negative locktime");
@@ -1423,7 +1708,7 @@ public class Script {
     }
 
     private static void executeCheckSig(Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack,
-                                        int lastCodeSepLocation, int opcode, 
+                                        int lastCodeSepLocation, int opcode, Coin value,
                                         Set<VerifyFlag> verifyFlags) throws ScriptException {
         final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)
             || verifyFlags.contains(VerifyFlag.DERSIG)
@@ -1451,7 +1736,9 @@ public class Script {
                 verifyFlags.contains(VerifyFlag.LOW_S));
 
             // TODO: Should check hash type is known
-            Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);
+            Sha256Hash hash = sig.useForkId() ?
+                                txContainingThis.hashForSignatureWitness(index, connectedScript, value, sig.sigHashMode(), sig.anyoneCanPay()) :
+                                txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);
             sigValid = ECKey.verify(hash.getBytes(), sig, pubKey);
         } catch (Exception e1) {
             // There is (at least) one exception that could be hit here (EOFException, if the sig is too short)
@@ -1471,14 +1758,15 @@ public class Script {
     }
 
     private static int executeMultiSig(Transaction txContainingThis, int index, Script script, LinkedList<byte[]> stack,
-                                       int opCount, int lastCodeSepLocation, int opcode, 
+                                       int opCount, int lastCodeSepLocation, int opcode, Coin value,
                                        Set<VerifyFlag> verifyFlags) throws ScriptException {
         final boolean requireCanonical = verifyFlags.contains(VerifyFlag.STRICTENC)
             || verifyFlags.contains(VerifyFlag.DERSIG)
             || verifyFlags.contains(VerifyFlag.LOW_S);
+        final boolean enforceMinimal = verifyFlags.contains(VerifyFlag.MINIMALDATA);
         if (stack.size() < 2)
             throw new ScriptException("Attempted OP_CHECKMULTISIG(VERIFY) on a stack with size < 2");
-        int pubKeyCount = castToBigInteger(stack.pollLast()).intValue();
+        int pubKeyCount = castToBigInteger(stack.pollLast(), enforceMinimal).intValue();
         if (pubKeyCount < 0 || pubKeyCount > 20)
             throw new ScriptException("OP_CHECKMULTISIG(VERIFY) with pubkey count out of range");
         opCount += pubKeyCount;
@@ -1493,7 +1781,7 @@ public class Script {
             pubkeys.add(pubKey);
         }
 
-        int sigCount = castToBigInteger(stack.pollLast()).intValue();
+        int sigCount = castToBigInteger(stack.pollLast(), enforceMinimal).intValue();
         if (sigCount < 0 || sigCount > pubKeyCount)
             throw new ScriptException("OP_CHECKMULTISIG(VERIFY) with sig count out of range");
         if (stack.size() < sigCount + 1)
@@ -1525,7 +1813,9 @@ public class Script {
             // more expensive than hashing, its not a big deal.
             try {
                 TransactionSignature sig = TransactionSignature.decodeFromBitcoin(sigs.getFirst(), requireCanonical);
-                Sha256Hash hash = txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);
+                Sha256Hash hash = sig.useForkId() ?
+                        txContainingThis.hashForSignatureWitness(index, connectedScript, value, sig.sigHashMode(), sig.anyoneCanPay()):
+                        txContainingThis.hashForSignature(index, connectedScript, (byte) sig.sighashFlags);
                 if (ECKey.verify(hash.getBytes(), sig, pubKey))
                     sigs.pollFirst();
             } catch (Exception e) {
@@ -1567,9 +1857,15 @@ public class Script {
     @Deprecated
     public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey)
             throws ScriptException {
-        correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, ALL_VERIFY_FLAGS);
+        correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, Coin.ZERO, ALL_VERIFY_FLAGS);
     }
 
+    @Deprecated
+    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey,
+                                Set<VerifyFlag> verifyFlags)
+            throws ScriptException {
+        correctlySpends(txContainingThis, scriptSigIndex, scriptPubKey, Coin.ZERO, verifyFlags);
+    }
     /**
      * Verifies that this script (interpreted as a scriptSig) correctly spends the given scriptPubKey.
      * @param txContainingThis The transaction in which this input scriptSig resides.
@@ -1579,7 +1875,7 @@ public class Script {
      * @param verifyFlags Each flag enables one validation rule. If in doubt, use {@link #correctlySpends(Transaction, long, Script)}
      *                    which sets all flags.
      */
-    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey,
+    public void correctlySpends(Transaction txContainingThis, long scriptSigIndex, Script scriptPubKey, Coin value,
                                 Set<VerifyFlag> verifyFlags) throws ScriptException {
         // Clone the transaction because executing the script involves editing it, and if we die, we'll leave
         // the tx half broken (also it's not so thread safe to work on it directly.
@@ -1594,10 +1890,10 @@ public class Script {
         LinkedList<byte[]> stack = new LinkedList<byte[]>();
         LinkedList<byte[]> p2shStack = null;
         
-        executeScript(txContainingThis, scriptSigIndex, this, stack, verifyFlags);
+        executeScript(txContainingThis, scriptSigIndex, this, stack, value, verifyFlags);
         if (verifyFlags.contains(VerifyFlag.P2SH))
             p2shStack = new LinkedList<byte[]>(stack);
-        executeScript(txContainingThis, scriptSigIndex, scriptPubKey, stack, verifyFlags);
+        executeScript(txContainingThis, scriptSigIndex, scriptPubKey, stack, value, verifyFlags);
         
         if (stack.size() == 0)
             throw new ScriptException("Stack empty at end of script execution.");
@@ -1626,7 +1922,7 @@ public class Script {
             byte[] scriptPubKeyBytes = p2shStack.pollLast();
             Script scriptPubKeyP2SH = new Script(scriptPubKeyBytes);
             
-            executeScript(txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, verifyFlags);
+            executeScript(txContainingThis, scriptSigIndex, scriptPubKeyP2SH, p2shStack, value, verifyFlags);
             
             if (p2shStack.size() == 0)
                 throw new ScriptException("P2SH stack empty at end of script execution.");
