diff --git a/core/src/main/java/org/bitcoinj/wallet/Wallet.java b/core/src/main/java/org/bitcoinj/wallet/Wallet.java
index 89b0b7085..b03fa3296 100644
--- a/core/src/main/java/org/bitcoinj/wallet/Wallet.java
+++ b/core/src/main/java/org/bitcoinj/wallet/Wallet.java
@@ -3264,16 +3264,17 @@ public class Wallet extends BaseTaggableObject
 
         for (Transaction tx : txns) {
             try {
-                builder.append("Sends ");
+                builder.append(tx.getValue(this).toFriendlyString());
+                builder.append(" total value (sends ");
                 builder.append(tx.getValueSentFromMe(this).toFriendlyString());
                 builder.append(" and receives ");
                 builder.append(tx.getValueSentToMe(this).toFriendlyString());
-                builder.append(", total value ");
-                builder.append(tx.getValue(this).toFriendlyString());
-                builder.append(".\n");
+                builder.append(")\n");
             } catch (ScriptException e) {
                 // Ignore and don't print this line.
             }
+            if (tx.hasConfidence())
+                builder.append("  confidence: ").append(tx.getConfidence()).append('\n');
             builder.append(tx.toString(chain));
         }
     }
@@ -3425,7 +3426,7 @@ public class Wallet extends BaseTaggableObject
     }
 
     /**
-     * Get the description of the wallet. See {@link Wallet#setDescription(String))}
+     * Get the description of the wallet. See {@link Wallet#setDescription(String)}
      */
     public String getDescription() {
         return description;
@@ -3702,7 +3703,7 @@ public class Wallet extends BaseTaggableObject
         USE_DUMMY_SIG,
         /**
          * If signature is missing, {@link org.bitcoinj.signers.TransactionSigner.MissingSignatureException}
-         * will be thrown for P2SH and {@link ECKey.MissingPrivateKeyException} for other tx types.
+         * will be thrown for P2SH and {@link org.bitcoinj.core.ECKey.MissingPrivateKeyException} for other tx types.
          */
         THROW
     }
@@ -3717,7 +3718,7 @@ public class Wallet extends BaseTaggableObject
      * and lets you see the proposed transaction before anything is done with it.</p>
      *
      * <p>This is a helper method that is equivalent to using {@link SendRequest#to(Address, Coin)}
-     * followed by {@link Wallet#completeTx(Wallet.SendRequest)} and returning the requests transaction object.
+     * followed by {@link Wallet#completeTx(SendRequest)} and returning the requests transaction object.
      * Note that this means a fee may be automatically added if required, if you want more control over the process,
      * just do those two steps yourself.</p>
      *
@@ -3750,7 +3751,7 @@ public class Wallet extends BaseTaggableObject
      * Sends coins to the given address but does not broadcast the resulting pending transaction. It is still stored
      * in the wallet, so when the wallet is added to a {@link PeerGroup} or {@link Peer} the transaction will be
      * announced to the network. The given {@link SendRequest} is completed first using
-     * {@link Wallet#completeTx(Wallet.SendRequest)} to make it valid.
+     * {@link Wallet#completeTx(SendRequest)} to make it valid.
      *
      * @return the Transaction that was created
      * @throws InsufficientMoneyException if the request could not be completed due to not enough balance.
@@ -3802,6 +3803,12 @@ public class Wallet extends BaseTaggableObject
         return sendCoins(broadcaster, request);
     }
 
+
+    public SendResult sendCoins(TransactionBroadcaster broadcaster, Address to, Coin value, boolean useforkId) throws InsufficientMoneyException {
+        SendRequest request = SendRequest.to(to, value);
+        request.setUseForkId(useforkId);
+        return sendCoins(broadcaster, request);
+    }
     /**
      * <p>Sends coins according to the given request, via the given {@link TransactionBroadcaster}.</p>
      *
@@ -3919,17 +3926,22 @@ public class Wallet extends BaseTaggableObject
      * @throws MultipleOpReturnRequested if there is more than one OP_RETURN output for the resultant transaction.
      */
     public void completeTx(SendRequest req) throws InsufficientMoneyException {
+        req.setUseForkId(true);     // this library will always send BCH transactions
         lock.lock();
         try {
             checkArgument(!req.completed, "Given SendRequest has already been completed.");
+            // set version
+            if(req.getUseForkId())
+                req.tx.setVersion(Transaction.CURRENT_VERSION);
+
             // Calculate the amount of value we need to import.
             Coin value = Coin.ZERO;
             for (TransactionOutput output : req.tx.getOutputs()) {
                 value = value.add(output.getValue());
             }
 
-            log.info("Completing send tx with {} outputs totalling {} (not including fees)",
-                    req.tx.getOutputs().size(), value.toFriendlyString());
+            log.info("Completing send tx with {} outputs totalling {} and a fee of {}/kB", req.tx.getOutputs().size(),
+                    value.toFriendlyString(), req.feePerKb.toFriendlyString());
 
             // If any inputs have already been added, we don't need to get their value from wallet
             Coin totalInput = Coin.ZERO;
@@ -4006,12 +4018,6 @@ public class Wallet extends BaseTaggableObject
             if (size > Transaction.MAX_STANDARD_TX_SIZE)
                 throw new ExceededMaxTransactionSize();
 
-            final Coin calculatedFee = req.tx.getFee();
-            if (calculatedFee != null)
-                log.info("  with a fee of {}/kB, {} for {} bytes",
-                        calculatedFee.multiply(1000).divide(size).toFriendlyString(), calculatedFee.toFriendlyString(),
-                        size);
-
             // Label the transaction as being self created. We can use this later to spend its change output even before
             // the transaction is confirmed. We deliberately won't bother notifying listeners here as there's not much
             // point - the user isn't interested in a confidence transition they made themselves.
@@ -4037,6 +4043,7 @@ public class Wallet extends BaseTaggableObject
      * transaction will be complete in the end.</p>
      */
     public void signTransaction(SendRequest req) {
+        req.setUseForkId(true);
         lock.lock();
         try {
             Transaction tx = req.tx;
@@ -4059,7 +4066,7 @@ public class Wallet extends BaseTaggableObject
                     // We assume if its already signed, its hopefully got a SIGHASH type that will not invalidate when
                     // we sign missing pieces (to check this would require either assuming any signatures are signing
                     // standard output types or a way to get processed signatures out of script execution)
-                    txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey());
+                    txIn.getScriptSig().correctlySpends(tx, i, txIn.getConnectedOutput().getScriptPubKey(), txIn.getConnectedOutput().getValue(), Script.ALL_VERIFY_FLAGS);
                     log.warn("Input {} already correctly spends output, assuming SIGHASH type used will be safe and skipping signing.", i);
                     continue;
                 } catch (ScriptException e) {
@@ -4073,7 +4080,7 @@ public class Wallet extends BaseTaggableObject
                 txIn.setScriptSig(scriptPubKey.createEmptyInputScript(redeemData.keys.get(0), redeemData.redeemScript));
             }
 
-            TransactionSigner.ProposedTransaction proposal = new TransactionSigner.ProposedTransaction(tx);
+            TransactionSigner.ProposedTransaction proposal = new TransactionSigner.ProposedTransaction(tx, req.getUseForkId());
             for (TransactionSigner signer : signers) {
                 if (!signer.signInputs(proposal, maybeDecryptingKeyBag))
                     log.info("{} returned false for the tx", signer.getClass().getName());
@@ -4655,8 +4662,8 @@ public class Wallet extends BaseTaggableObject
      * <p>This is used to generate a BloomFilter which can be {@link BloomFilter#merge(BloomFilter)}d with another.
      * It could also be used if you have a specific target for the filter's size.</p>
      * 
-     * <p>See the docs for {@link BloomFilter(int, double)} for a brief explanation of anonymity when using bloom
-     * filters.</p>
+     * <p>See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief explanation of
+     * anonymity when using bloom filters.</p>
      */
     @Override @GuardedBy("keyChainGroupLock")
     public BloomFilter getBloomFilter(int size, double falsePositiveRate, long nTweak) {
@@ -4834,8 +4841,7 @@ public class Wallet extends BaseTaggableObject
         TransactionOutput selection2Change = null;
         CoinSelection selection1 = null;
         TransactionOutput selection1Change = null;
-        // We keep track of the last size of the transaction we calculated but only if the act of adding inputs and
-        // change resulted in the size crossing a 1000 byte boundary. Otherwise it stays at zero.
+        // We keep track of the last size of the transaction we calculated.
         int lastCalculatedSize = 0;
         Coin valueNeeded, valueMissing = null;
         while (true) {
@@ -5068,7 +5074,9 @@ public class Wallet extends BaseTaggableObject
         // Don't hold the wallet lock whilst doing this, so if the broadcaster accesses the wallet at some point there
         // is no inversion.
         for (Transaction tx : toBroadcast) {
-            checkState(tx.getConfidence().getConfidenceType() == ConfidenceType.PENDING);
+            ConfidenceType confidenceType = tx.getConfidence().getConfidenceType();
+            checkState(confidenceType == ConfidenceType.PENDING || confidenceType == ConfidenceType.IN_CONFLICT,
+                    "Expected PENDING or IN_CONFLICT, was %s.", confidenceType);
             // Re-broadcast even if it's marked as already seen for two reasons
             // 1) Old wallets may have transactions marked as broadcast by 1 peer when in reality the network
             //    never saw it, due to bugs.
