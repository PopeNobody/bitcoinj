diff --git a/core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java b/core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
index 80714ce90..101a62b14 100644
--- a/core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
+++ b/core/src/main/java/org/bitcoinj/wallet/DefaultRiskAnalysis.java
@@ -1,6 +1,7 @@
 /*
  * Copyright 2013 Google Inc.
  * Copyright 2014 Andreas Schildbach
+ * Copyright 2018 the bitcoinj-cash developers
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,6 +14,9 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file has been modified by the bitcoinj-cash developers for the bitcoinj-cash project.
+ * The original file was from the bitcoinj project (https://github.com/bitcoinj/bitcoinj).
  */
 
 package org.bitcoinj.wallet;
@@ -83,12 +87,6 @@ public class DefaultRiskAnalysis implements RiskAnalysis {
         if (tx.getConfidence().getSource() == TransactionConfidence.Source.SELF)
             return Result.OK;
 
-        // We consider transactions that opt into replace-by-fee at risk of double spending.
-        if (tx.isOptInFullRBF()) {
-            nonFinal = tx;
-            return Result.NON_FINAL;
-        }
-
         if (wallet == null)
             return null;
 
@@ -122,7 +120,8 @@ public class DefaultRiskAnalysis implements RiskAnalysis {
         DUST,
         SHORTEST_POSSIBLE_PUSHDATA,
         NONEMPTY_STACK, // Not yet implemented (for post 0.12)
-        SIGNATURE_CANONICAL_ENCODING
+        SIGNATURE_CANONICAL_ENCODING,
+        SIGNATURE_MISSING_FORKID,
     }
 
     /**
@@ -133,7 +132,7 @@ public class DefaultRiskAnalysis implements RiskAnalysis {
      */
     public static RuleViolation isStandard(Transaction tx) {
         // TODO: Finish this function off.
-        if (tx.getVersion() > 1 || tx.getVersion() < 1) {
+        if (tx.getVersion() > 2 || tx.getVersion() < 1) {
             log.warn("TX considered non-standard due to unknown version number {}", tx.getVersion());
             return RuleViolation.VERSION;
         }
@@ -198,6 +197,28 @@ public class DefaultRiskAnalysis implements RiskAnalysis {
         return RuleViolation.NONE;
     }
 
+    /** Checks if the given input passes some of the AreInputsStandard checks. Not complete. */
+    public static RuleViolation isInputSignedWithForkId(TransactionInput input, boolean requireForkId) {
+        for (ScriptChunk chunk : input.getScriptSig().getChunks()) {
+            if (chunk.data != null && !chunk.isShortestPossiblePushData())
+                return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;
+            if (chunk.isPushData()) {
+                ECDSASignature signature;
+                try {
+                    signature = ECKey.ECDSASignature.decodeFromDER(chunk.data);
+                } catch (RuntimeException x) {
+                    // Doesn't look like a signature.
+                    signature = null;
+                }
+                if (signature != null && requireForkId) {
+                    if (!TransactionSignature.hasForkId(chunk.data))
+                        return RuleViolation.SIGNATURE_MISSING_FORKID;
+                }
+            }
+        }
+        return RuleViolation.NONE;
+    }
+
     private Result analyzeIsStandard() {
         // The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't want to
         // crush innovation with valueless test coins.
@@ -210,6 +231,20 @@ public class DefaultRiskAnalysis implements RiskAnalysis {
             return Result.NON_STANDARD;
         }
 
+        long time = wallet.getLastBlockSeenTimeSecs();
+
+        final List<TransactionInput> inputs = tx.getInputs();
+        for (int i = 0; i < inputs.size(); i++) {
+            TransactionInput input = inputs.get(i);
+            RuleViolation violation = isInputSignedWithForkId(input, time > 1501590000);
+            if (violation != RuleViolation.NONE) {
+                log.warn("TX considered non-standard due to input {} violating rule {}", i, violation);
+                return Result.NON_STANDARD;
+            }
+        }
+
+
+
         for (Transaction dep : dependencies) {
             ruleViolation = isStandard(dep);
             if (ruleViolation != RuleViolation.NONE) {
