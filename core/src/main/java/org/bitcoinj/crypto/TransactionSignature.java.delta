diff --git a/core/src/main/java/org/bitcoinj/crypto/TransactionSignature.java b/core/src/main/java/org/bitcoinj/crypto/TransactionSignature.java
index 545804a1b..2abc38736 100644
--- a/core/src/main/java/org/bitcoinj/crypto/TransactionSignature.java
+++ b/core/src/main/java/org/bitcoinj/crypto/TransactionSignature.java
@@ -54,6 +54,10 @@ public class TransactionSignature extends ECKey.ECDSASignature {
         super(signature.r, signature.s);
         sighashFlags = calcSigHashValue(mode, anyoneCanPay);
     }
+    public TransactionSignature(ECKey.ECDSASignature signature, Transaction.SigHash mode, boolean anyoneCanPay, boolean useForkId) {
+        super(signature.r, signature.s);
+        sighashFlags = calcSigHashValue(mode, anyoneCanPay, useForkId);
+    }
 
     /**
      * Returns a dummy invalid signature whose R/S values are set such that they will take up the same number of
@@ -75,6 +79,16 @@ public class TransactionSignature extends ECKey.ECDSASignature {
         return sighashFlags;
     }
 
+    public static int calcSigHashValue(Transaction.SigHash mode, boolean anyoneCanPay, boolean useForkId) {
+        Preconditions.checkArgument(SigHash.ALL == mode || SigHash.NONE == mode || SigHash.SINGLE == mode); // enforce compatibility since this code was made before the SigHash enum was updated
+        int sighashFlags = mode.value;
+        if (anyoneCanPay)
+            sighashFlags |= Transaction.SigHash.ANYONECANPAY.value;
+        if(useForkId)
+            sighashFlags |= SigHash.FORKID.value;
+        return sighashFlags;
+    }
+
     /**
      * Returns true if the given signature is has canonical encoding, and will thus be accepted as standard by
      * Bitcoin Core. DER and the SIGHASH encoding allow for quite some flexibility in how the same structures
@@ -92,7 +106,7 @@ public class TransactionSignature extends ECKey.ECDSASignature {
         if (signature.length < 9 || signature.length > 73)
             return false;
 
-        int hashType = (signature[signature.length-1] & 0xff) & ~Transaction.SigHash.ANYONECANPAY.value; // mask the byte to prevent sign-extension hurting us
+        int hashType = (signature[signature.length-1] & 0xff) & ~(Transaction.SigHash.ANYONECANPAY.value| SigHash.FORKID.value); // mask the byte to prevent sign-extension hurting us
         if (hashType < Transaction.SigHash.ALL.value || hashType > Transaction.SigHash.SINGLE.value)
             return false;
 
@@ -122,9 +136,19 @@ public class TransactionSignature extends ECKey.ECDSASignature {
         return true;
     }
 
+    public static boolean hasForkId (byte[] signature)
+    {
+        int forkId = (signature[signature.length-1] & 0xff) & SigHash.FORKID.value; // mask the byte to prevent sign-extension hurting us
+
+        return forkId == SigHash.FORKID.value;
+    }
+
     public boolean anyoneCanPay() {
         return (sighashFlags & Transaction.SigHash.ANYONECANPAY.value) != 0;
     }
+    public boolean useForkId() {
+        return (sighashFlags & SigHash.FORKID.value) != 0;
+    }
 
     public Transaction.SigHash sigHashMode() {
         final int mode = sighashFlags & 0x1f;
@@ -153,7 +177,7 @@ public class TransactionSignature extends ECKey.ECDSASignature {
 
     @Override
     public ECKey.ECDSASignature toCanonicalised() {
-        return new TransactionSignature(super.toCanonicalised(), sigHashMode(), anyoneCanPay());
+        return new TransactionSignature(super.toCanonicalised(), sigHashMode(), anyoneCanPay(), useForkId());
     }
 
     /**
@@ -162,7 +186,7 @@ public class TransactionSignature extends ECKey.ECDSASignature {
      * @param requireCanonicalEncoding if the encoding of the signature must
      * be canonical.
      * @throws RuntimeException if the signature is invalid or unparseable in some way.
-     * @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean} instead}.
+     * @deprecated use {@link #decodeFromBitcoin(byte[], boolean, boolean)} instead.
      */
     @Deprecated
     public static TransactionSignature decodeFromBitcoin(byte[] bytes,
