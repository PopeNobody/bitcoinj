diff --git a/core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientState.java b/core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientState.java
index dd4e0b6cd..d1e27d60e 100644
--- a/core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientState.java
+++ b/core/src/main/java/org/bitcoinj/protocols/channels/PaymentChannelClientState.java
@@ -211,7 +211,7 @@ public abstract class PaymentChannelClientState {
      * Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate
      * time using {@link PaymentChannelV1ClientState#getIncompleteRefundTransaction} and
      * {@link PaymentChannelV1ClientState#getContract()}. The way the contract is crafted can be adjusted by
-     * overriding {@link PaymentChannelV1ClientState#editContractSendRequest(org.bitcoinj.wallet.Wallet.SendRequest)}.
+     * overriding {@link PaymentChannelV1ClientState#editContractSendRequest(org.bitcoinj.wallet.SendRequest)}.
      * By default unconfirmed coins are allowed to be used, as for micropayments the risk should be relatively low.
      *
      * @throws ValueOutOfRangeException if the value being used is too small to be accepted by the network
@@ -225,7 +225,7 @@ public abstract class PaymentChannelClientState {
      * Creates the initial multisig contract and incomplete refund transaction which can be requested at the appropriate
      * time using {@link PaymentChannelV1ClientState#getIncompleteRefundTransaction} and
      * {@link PaymentChannelV1ClientState#getContract()}. The way the contract is crafted can be adjusted by
-     * overriding {@link PaymentChannelV1ClientState#editContractSendRequest(org.bitcoinj.wallet.Wallet.SendRequest)}.
+     * overriding {@link PaymentChannelV1ClientState#editContractSendRequest(org.bitcoinj.wallet.SendRequest)}.
      * By default unconfirmed coins are allowed to be used, as for micropayments the risk should be relatively low.
      * @param userKey Key derived from a user password, needed for any signing when the wallet is encrypted.
      *                  The wallet KeyCrypter is assumed.
@@ -315,7 +315,9 @@ public abstract class PaymentChannelClientState {
             mode = Transaction.SigHash.NONE;
         else
             mode = Transaction.SigHash.SINGLE;
-        TransactionSignature sig = tx.calculateSignature(0, myKey.maybeDecrypt(userKey), getSignedScript(), mode, true);
+        TransactionSignature sig = tx.getVersion() >= Transaction.FORKID_VERSION ?
+                tx.calculateWitnessSignature(0, myKey.maybeDecrypt(userKey), getSignedScript(), tx.getInput(0).getConnectedOutput().getValue(), mode, true) :
+                tx.calculateSignature(0, myKey.maybeDecrypt(userKey), getSignedScript(), mode, true);
         valueToMe = newValueToMe;
         updateChannelInWallet();
         IncrementedPayment payment = new IncrementedPayment();
@@ -424,7 +426,7 @@ public abstract class PaymentChannelClientState {
 
     /**
      * Gets the contract without changing the state machine
-     * @return
+     * @return the {@link Transaction}
      */
     protected abstract Transaction getContractInternal();
 
@@ -433,7 +435,7 @@ public abstract class PaymentChannelClientState {
     /**
      * Gets the script that is signed. In the case of a P2SH contract this is the
      * script inside the P2SH script.
-     * @return
+     * @return the {@link Script}
      */
     protected abstract Script getSignedScript();
 }
